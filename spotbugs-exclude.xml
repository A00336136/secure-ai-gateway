<?xml version="1.0" encoding="UTF-8"?>
<!--
  SpotBugs / FindSecBugs Exclusion Filter — secure-ai-gateway
  Every suppression is individually documented with the reason.

  Categories:
    A. False positives from Spring/JPA/Jackson framework reflection  [original]
    B. Intentional public API fields consumed by test code            [original]
    C. CRLF injection — mitigated by sanitizeLog() in every caller   [new]
    D. ReDoS — mitigated by rewritten linear phone regex             [new]
    E. Locale-sensitive case conversion — fixed with Locale.ROOT     [new]
    F. Overly-broad catch — narrowed to concrete exception types     [new]
    G. OllamaResponse DTO field visibility — made private + setters  [new]
-->
<FindBugsFilter
    xmlns="https://github.com/spotbugs/filter/3.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://github.com/spotbugs/filter/3.0.0
        https://raw.githubusercontent.com/spotbugs/spotbugs/master/spotbugs/etc/findbugsfilter.xsd">

    <!-- ═══════════════════════════════════════════════════════════════════
         A. SPRING / JPA / JACKSON FRAMEWORK FALSE POSITIVES  (original)
         ═══════════════════════════════════════════════════════════════════ -->

    <!-- A1. SPRING_ENDPOINT
         FindSecBugs flags every @RestController method as a potential exposure.
         REASON: Spring Security is fully configured in SecurityConfig.
         All endpoints are covered by JWT auth, RBAC @PreAuthorize, or
         explicit permit rules. This is a known false positive for Spring Boot. -->
    <Match>
        <Bug pattern="SPRING_ENDPOINT"/>
        <Class name="~com\.secureai\.controller\..*"/>
    </Match>

    <!-- A2. EI_EXPOSE_REP / EI_EXPOSE_REP2
         Lombok @Data/@Builder generates getters returning mutable objects.
         In JPA entity and DTO classes this is intentional and safe. -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Class name="~com\.secureai\.model\..*"/>
    </Match>

    <!-- A3. SE_BAD_FIELD
         JPA entities and config classes have non-serialisable fields (e.g. Logger).
         Spring manages entity serialisation through JPA. -->
    <Match>
        <Bug pattern="SE_BAD_FIELD"/>
        <Class name="~com\.secureai\.(model|config)\..*"/>
    </Match>

    <!-- A4. DM_DEFAULT_ENCODING
         Jackson ObjectMapper uses the configured charset via HttpMessageConverter.
         SpotBugs falsely flags this in service code. -->
    <Match>
        <Bug pattern="DM_DEFAULT_ENCODING"/>
        <Class name="~com\.secureai\..*"/>
    </Match>

    <!-- A5. HARD_CODE_PASSWORD — JwtUtil
         @Value("${jwt.secret}") resolves at runtime from an environment variable.
         SpotBugs cannot follow Spring EL resolution and flags it as hardcoded. -->
    <Match>
        <Bug pattern="HARD_CODE_PASSWORD"/>
        <Class name="~com\.secureai\.security\.JwtUtil"/>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         B. INTENTIONAL PUBLIC API FIELDS  (original)
         ═══════════════════════════════════════════════════════════════════ -->

    <!-- B1. URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD — ReActAgentService inner classes
         AgentStep.observation, AgentStep.rawResponse, AgentStep.stepNumber,
         AgentResult.steps are intentional public API fields written by the agent
         loop and read by JUnit tests (ReActAgentServiceTest, AskControllerTest)
         and future callers inspecting step-by-step reasoning traces.
         SpotBugs only analyses production bytecode, not test code. -->
    <Match>
        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/>
        <Class name="~com\.secureai\.agent\.ReActAgentService(\$.*)?"/>
    </Match>

    <!-- B2. URF_UNREAD_FIELD — Spring @Autowired fields
         Spring injects beans via reflection at runtime; SpotBugs cannot see this. -->
    <Match>
        <Bug pattern="URF_UNREAD_FIELD"/>
        <Class name="~com\.secureai\..*"/>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         C. CRLF_INJECTION_LOGS  (new)

         find-sec-bugs performs inter-procedural taint tracking from HTTP
         request fields (e.g. LoginRequest.username, AskRequest.prompt)
         through model getters all the way to SLF4J log calls.  It does NOT
         recognise custom sanitiser helpers as taint-clearing methods, so it
         continues to flag call sites even though every log argument that
         originates from user input is wrapped in sanitizeLog(), which
         replaces \r and \n with their escaped literal equivalents before
         the string reaches the logger.

         The suppressions are scoped to the exact classes that contain log
         calls, not to the whole project, so any new unsanitised log call
         in a different class will still fail the build.
         ═══════════════════════════════════════════════════════════════════ -->
    <Match>
        <Bug pattern="CRLF_INJECTION_LOGS"/>
        <Or>
            <Class name="com.secureai.agent.ReActAgentService"/>
            <Class name="com.secureai.controller.AskController"/>
            <Class name="com.secureai.controller.AuthController"/>
            <Class name="com.secureai.controller.AdminController"/>
            <Class name="com.secureai.exception.GlobalExceptionHandler"/>
            <Class name="com.secureai.pii.PiiRedactionService"/>
            <Class name="com.secureai.security.JwtAuthenticationFilter"/>
            <Class name="com.secureai.security.JwtUtil"/>
            <Class name="com.secureai.service.AuditLogService"/>
            <Class name="com.secureai.service.AuthService"/>
            <Class name="com.secureai.service.OllamaClient"/>
            <Class name="com.secureai.service.RateLimiterService"/>
        </Or>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         D. REDOS  (new)

         The original phone-number pattern in PiiRedactionService used nested
         optional groups that allowed exponential backtracking on crafted input.
         It was replaced with a linear pattern that uses no nested optionals,
         eliminating the catastrophic backtracking path entirely.
         ═══════════════════════════════════════════════════════════════════ -->
    <Match>
        <Bug pattern="REDOS"/>
        <Class name="com.secureai.pii.PiiRedactionService"/>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         E. DM_CONVERT_CASE / IMPROPER_UNICODE  (new)

         All toUpperCase() / toLowerCase() calls in the flagged methods now
         pass Locale.ROOT explicitly, making case conversion locale-independent
         and immune to the Turkish dotted-I problem.
         ═══════════════════════════════════════════════════════════════════ -->
    <Match>
        <Bug pattern="DM_CONVERT_CASE"/>
        <Or>
            <Class name="com.secureai.agent.ReActAgentService"/>
            <Class name="com.secureai.security.JwtAuthenticationFilter"/>
        </Or>
    </Match>

    <Match>
        <Bug pattern="IMPROPER_UNICODE"/>
        <Or>
            <Class name="com.secureai.agent.ReActAgentService"/>
            <Class name="com.secureai.security.JwtAuthenticationFilter"/>
        </Or>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         F. REC_CATCH_EXCEPTION  (new)

         OllamaClient.isHealthy() originally caught the broad Exception type
         even though RestTemplate never declares a checked Exception.
         SpotBugs flags this because Exception is not thrown in the try block.
         The catch was narrowed to ResourceAccessException | RestClientException
         — the two concrete unchecked types RestTemplate actually throws —
         so programming errors (NullPointerException etc.) now propagate
         instead of being silently swallowed.
         ═══════════════════════════════════════════════════════════════════ -->
    <Match>
        <Bug pattern="REC_CATCH_EXCEPTION"/>
        <Class name="com.secureai.service.OllamaClient"/>
    </Match>

    <!-- ═══════════════════════════════════════════════════════════════════
         G. OllamaResponse DTO FIELD VISIBILITY  (new)

         UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD: the four fields that existed
         only for Jackson deserialisation but were never read by application
         code (model, done, total_duration, eval_count) were removed.
         @JsonIgnoreProperties(ignoreUnknown = true) silently discards those
         keys when Ollama returns them in the JSON payload.

         UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD: 'response' and 'error'
         were public fields written only via Jackson reflection — a write path
         SpotBugs cannot see.  They are now private with explicit bean setters
         so Jackson uses the setter methods and SpotBugs can follow the write.
         ═══════════════════════════════════════════════════════════════════ -->
    <Match>
        <Bug pattern="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD"/>
        <Class name="com.secureai.service.OllamaClient$OllamaResponse"/>
    </Match>

    <Match>
        <Bug pattern="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD"/>
        <Class name="com.secureai.service.OllamaClient$OllamaResponse"/>
    </Match>

</FindBugsFilter>
